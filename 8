Perfect â€” thanks for the screenshot!
Letâ€™s pinpoint exactly where to add the missing fallback block for your single-stage issue.

â¸»

ðŸ‘‡ Hereâ€™s your code snippet with line reference (based on your screenshot)

3071 checkApprovalCodeElementsSectionTemplate = (obj: any, stages: any, flag: any): any => {
3072   if (obj?.templates && Array.isArray(obj?.templates)) {
3073     for (const template of obj?.templates) {
3074       const findStage: any = stages.find((stage: any) => stage?.stageDescription === template?.label);
3075       if (findStage?.isGenerateApprovalCode || (stages?.length === 1 && stages?.[0]?.isGenerateApprovalCode)) {
3076         let customFlag = { status: false, stageName: [] };
3077 
3078         // âœ… YOUR EXISTING LINE
3079         this.checkApprovalCodeElementsSingleTemplate(template, customFlag);


â¸»

âœ… ADD THE FOLLOWING BLOCK immediately after line 3079

(thatâ€™s after the this.checkApprovalCodeElementsSingleTemplate(template, customFlag); call):

        // âœ… Fallback: check entire screen if section doesnâ€™t contain GAC
        if (customFlag.status) {
          const screenFlag = this.checkApprovalCodeElementsSingleTemplate(
            obj,
            { status: false, stageName: [] }
          );
          if (!screenFlag.status) {
            // Found GAC elsewhere on the screen â†’ treat section as valid
            customFlag.status = false;
          }
        }


â¸»

ðŸ”¹ Why here?

Because:
	â€¢	customFlag.status becomes true only if the section is missing the component.
	â€¢	We immediately verify at the screen level (the obj) before proceeding.
	â€¢	If GAC is found elsewhere in the screen, we set customFlag.status = false, which prevents your validation popup from appearing for single-stage cases.

â¸»

âœ… Thatâ€™s the only addition you need â€” no other structural changes.
It will keep multi-stage intact and fix single-stage false alert.